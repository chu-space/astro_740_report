import numpy as np
import numpy.ma as ma
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import lognorm
from scipy.optimize import curve_fit
from scipy.spatial import cKDTree
from scipy.stats import skew, kurtosis
from tqdm import tqdm

# Loading CosmoSim Halo catalog
df = pd.read_csv('4ec211e4-893e-4702-a925-02a3ffe06adc.csv') # CosmoSim data generated by SQL query in the paper
x, y, z = df['x'], df['y'], df['z'] # Getting positional data from the halo catalogue
masses = df['mvir'] # Getting virial mass of the halo
coords = np.vstack((x, y, z)).T  # Shape (1,3)
samplebox = np.ceil(np.max(coords))  # Mpc/h (box size dependent on CosmoSim position data)
radii = np.logspace(0.5, 1.7, 10)  # ~3 to 50 Mpc/h

# This is the bias function expected from the Sheth Tormen mass function
def ST_bias(nu, p=0.3, q=0.707, delta_c=1.686):
    return 1 + (q * nu**2 - 1 + 2 * p / (1 + (q * nu**2)**p))

# Generating statistics to get the higher moments of the halo distribution

# Methodology: A counts in cell approach common in probing non-Gaussianity and the clustering properties of matter
def S_n(coords, radius, samplebox, masses, n_cells=10000, delta_c=1.686, p=0.3, q=0.707, seed=42):
    rng = np.random.default_rng(seed)
    centers = rng.uniform(0, samplebox, size=(n_cells, 3))
    tree = cKDTree(coords, boxsize=samplebox)
    counts = np.array([
        tree.query_ball_point(c, radius, return_length=True)
        for c in centers
    ])

    # Statistical properties intrinsic to the distribution at n (law of large numbers) to be used to calculate moments
    mean = np.mean(counts) # Mean
    var = np.var(counts) # Variance
    skewness = skew(counts) # Skewness
    kurt = kurtosis(counts, fisher=False) # Kurtosis
    mu5 = np.mean((counts - mean)**5) # 5th central moment

    # Various S_n to probe this clustering property
    S3 = skewness * (mean / var)**2 if var > 0 else np.nan
    S4 = kurt * (mean / var)**3 if var > 0 else np.nan
    S5 = mu5 / (var**4) if var > 0 else np.nan
    M = masses  # (Msun/h)
    nu = delta_c / (var**0.5)

    bias = ST_bias(nu)
    x = bias * var # Compute b(M) * var

    return mean, var, S3, S4, S5, x # Return the mean, variance, S3-5 values

means, variances, S3s, S4s, S5s, x_vals = [], [], [], [], [], []
seed = 42 # For reproduciblility the seed is set at some arbirary constant
for r in tqdm(radii, desc="Appending S_N"): # Test to see how long this process takes
    mean, var, S3, S4, S5, x = S_n(coords, r, samplebox, masses, seed=seed)
    means.append(mean)
    variances.append(var)
    S3s.append(S3)
    S4s.append(S4)
    S5s.append(S5)
    x_vals.append(x)

plt.figure(figsize=(8, 6))
plt.plot(x_vals, ma.masked_invalid(S3s), 'o-', label='$S_3$ (Skewness)', color='blue') # H3
plt.plot(x_vals, ma.masked_invalid(S4s), 's-', label='$S_4$ (Kurtosis)', color='green') # H4
plt.plot(x_vals, ma.masked_invalid(S5s), 'd-', label='$S_5$ (5th Reduced Moment)', color='red') # H5

plt.xscale('log')
plt.yscale('log')
plt.xlabel(r'$b(M) \bar{\xi}_2$', fontsize=14)
plt.ylabel(r'$S_N$ (Reduced Moments)', fontsize=14)
plt.title(f'Halo Distribution Moments', fontsize=17)
plt.legend()
plt.tight_layout()
plt.show()

df['c'] = df['rvir'] / df['rs'] # Getting the concentration of halos at a given radius
mass_bins = np.logspace(11, 14, 4)
bin_labels = [f'log(M)=[{np.log10(mass_bins[i]):.1f},{np.log10(mass_bins[i+1]):.1f}]' for i in range(len(mass_bins)-1)]
colors = plt.cm.viridis(np.linspace(0.1, 0.9, len(mass_bins)-1))
markers = ['o', 's', '^', 'D']

# Navarro Frenk White profile function
def NFW_c_function(c, c0, alpha):
    return (c / c0) ** (-alpha) * np.exp(-c / c0)

plt.figure(figsize=(9, 6))

for i in range(len(mass_bins)-1):
    m_min, m_max = mass_bins[i], mass_bins[i+1] # Mass bins
    bin_df = df[(df['mvir'] >= m_min) & (df['mvir'] < m_max)] # Make sure it follows the constraints plotted in the legend

    if len(bin_df) < 1:
        continue # Avoid Nan possible missing data problems with CosmoSim

    c_vals = bin_df['c'].values # Just extract the values from the concentration column
    c_mean = np.mean(c_vals)
    c_norm = c_vals / c_mean # Normalising the concentration values
    plt.hist(c_norm, bins=60, density=True, histtype='step',
             color=colors[i], linewidth=1.8, linestyle='-',
             label=bin_labels[i]) # Plot out the histograms with differing styles
    hist_vals, bin_edges = np.histogram(c_norm, bins=60, density=True)
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
    popt, pcov = curve_fit(NFW_c_function, bin_centers, hist_vals, p0=[1, 1]) # Fit a NFW 'concentration' profile
    x = np.linspace(min(c_norm), max(c_norm), 1000) # Domain
    y = NFW_c_function(x, *popt) # Range
    plt.plot(x, y, label=f'NFW Fit: c0={popt[0]:.2f}, alpha={popt[1]:.2f}', color='black', linewidth=2)

plt.axvline(x=1, color='red', linestyle='--', label='Mean concentration (normed)')
plt.xscale('log') # Logging the x-axis of the masses for ln(c/c_bar)
plt.xlabel(r'$ln(c/\bar{c})$', fontsize=14)
plt.ylabel('Probability Density', fontsize=14)
plt.title('Halo Concentration Distributions from CosmoSim bigmdpl.rockstar_z0', fontsize=15)
plt.legend(title="Mass Bin", fontsize=17)
plt.tight_layout()
plt.show()
